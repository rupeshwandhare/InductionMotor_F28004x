//#############################################################################
//
// FILE:   vienna.h
//
//TITLE: solution hardware abstraction layer header file
//        This file consists of common variables and functions
//        for a particular hardware board, like functions to read current
//        and voltage signals on the board and functions to setup the
//        basic peripherals of the board
//
//#############################################################################
// $TI Release: TIDM_1000 v4.01.01.00 $
// $Release Date: Tue Nov  3 10:37:49 CST 2020 $
// $Copyright:
// Copyright (C) 2020 Texas Instruments Incorporated - http://www.ti.com/
//
// ALL RIGHTS RESERVED
// $
//#############################################################################


#ifndef VIENNA_H
#define VIENNA_H

#ifdef __cplusplus

extern "C" {
#endif

//************************ the includes *************************************

//#include "F28x_Project.h"

#include <stdint.h>
#include "device.h"

/*
#ifndef __TMS320C28XX_CLA__
#include <math.h>
#else
#include <CLAmath.h>
#endif
*/
//BELOW IS NEWLY ADDED RUPESH

#if VIENNA_CONTROL_RUNNING_ON == C28x_CORE
    #include <math.h>
#endif

#if VIENNA_CONTROL_RUNNING_ON == CLA_CORE
    #include <CLAmath.h>
#endif


//
// this is the file generated by the powerSUITE page for this system
//


#include "vienna_settings.h"
#include "vienna_hal.h"


//
// Library header files
// DCL Library is used for the controller implementation
// GV -> parallel form of DCL_PI for voltage loop (gv),
//
#ifndef __TMS320C28XX_CLA__
#include "DCLF32.h"

#define VIENNA_GV DCL_PI
//
// gv on C28x, run DCL_PI routine written in assembly
//
#define VIENNA_GV_RUN DCL_runPI_C4

#else
#include "DCLCLA.h"

#define VIENNA_GV DCL_PI_CLA

//
// gv on CLA, run DCL_PI routine written as inline function
// because it is called in the background task
//
#define VIENNA_GV_RUN DCL_runPI_L2

#endif

#include "dlog_4ch.h"

#include "power_meas_sine_analyzer.h"
#pragma FUNC_ALWAYS_INLINE(POWER_MEAS_SINE_ANALYZER_run)
#ifndef __TMS320C28XX_CLA__
#include "sfra_f32.h"
#include "sfra_gui_scicomms_driverlib.h"
#define VIENNA_SFRA_INJECT SFRA_F32_inject
#define VIENNA_SFRA_COLLECT SFRA_F32_collect
#else
#define VIENNA_SFRA_INJECT(m)    m
#define VIENNA_SFRA_COLLECT(m, n)
#endif


#define EMAVG_MACRO(in, out)  out = ((in - out) * (float32_t)0.000528) + out;

//
// System Settings
//
#define VIENNA_GRID_MAX_FREQ_HZ ((float32_t)110)
#define VIENNA_GRID_MIN_FREQ_HZ ((float32_t)40)

#define VIENNA_SD32_PU_SCALE_FACTOR ((float32_t)(1.0f / ((float32_t)VIENNA_SDFM_OSR * VIENNA_SDFM_OSR * VIENNA_SDFM_OSR)))

#define VIENNA_ALL_PHASE_ENABLED 1
#define VIENNA_CHECK_PHASE 2


/*
#define PowerRelay  GpioDataRegs.GPADAT.bit.GPIO14
#define DisablePWM  GpioDataRegs.GPADAT.bit.GPIO22
*/
//
// typedefs
//

enum VIENNA_boardState_enum {
    PowerStageOFF = 0,
    PowerStageON = 1,
    TripCondition = 2,
};

enum VIENNA_BuildLevel_enum {
    BuildLevel_1_OpenLoop = 0,
    BuildLevel_2_CurrentLoop = 1,
    BuildLevel_3_VoltageAndCurrentLoop = 2,
    BuildLevel_4_BalanceVoltageAndCurrentLoop = 3,
    BuildLevel_1_OpenLoop_CLA = 4,
    BuildLevel_2_CurrentLoop_CLA = 5,
    BuildLevel_3_VoltageAndCurrentLoop_CLA = 6,
    BuildLevel_4_BalanceVoltageAndCurrentLoop_CLA = 7,

};

enum VIENNA_boardStatus_enum {
    boardStatus_Idle = 0,
    boardStatus_NoFault = 1,
    boardStatus_OverCurrentTrip_IL1 = 2,
    boardStatus_OverCurrentTrip_IL2 = 3,
    boardStatus_OverCurrentTrip_IL3 = 4,
    boardStatus_OverCurrentTrip = 5,
    boardStatus_OverVoltageTrip = 6,
    vpv1_overvoltage = 7,
    boardStatus_EmulatorStopTrip = 8,
    vdc_undervoltage=9,
    vpv2_overvoltage = 10,
};

//
//********************** globals **********************************************
//

/*
//
// DCL Library, voltage compensator
// DC Bus set point
//
extern volatile float32_t VIENNA_vBusRef_pu;
extern volatile float32_t VIENNA_vBusRefSlewed_pu;

extern VIENNA_GV VIENNA_gv;

extern volatile float32_t VIENNA_gv_out,  VIENNA_voltage_error_pu;
extern volatile uint16_t VIENNA_nonLinearVoltageLoopFlag;

//
// Current compensator
// Peak value of the Ii, Io current set point
//
extern volatile float32_t VIENNA_iLRef_pu, VIENNA_iL1Ref_pu, VIENNA_iL2Ref_pu,
                          VIENNA_iL3Ref_pu;

extern volatile float32_t VIENNA_gi_out1, VIENNA_gi_out2, VIENNA_gi_out3;
extern volatile float32_t VIENNA_gi_gainKp;

//
// Balance controller
//
extern volatile float32_t VIENNA_gs_gainKp;
extern volatile float32_t VIENNA_gs_out;

extern volatile float32_t VIENNA_vBusDiff_pu, VIENNA_vBusZero_pu;
*/

/*
//
// Sine analyzer block for RMS Volt, Curr and Power measurements
//
extern POWER_MEAS_SINE_ANALYZER VIENNA_sine_mains1, VIENNA_sine_mains2,
                                VIENNA_sine_mains3;
*/

//
// Control Variables
// Measurement Variables
// Inductor Current Measurement
//
extern volatile float32_t VIENNA_iL1MeasADC_pu, VIENNA_iL2MeasADC_pu,
                          VIENNA_iL3MeasADC_pu;
extern volatile float32_t VIENNA_iL1MeasSD_pu, VIENNA_iL2MeasSD_pu,
                          VIENNA_iL3MeasSD_pu;
//extern volatile float32_t VIENNA_iL1Meas_pu, VIENNA_iL2Meas_pu, VIENNA_iL3Meas_pu;
extern volatile float32_t VIENNA_iL1Meas_pu, VIENNA_iL2Meas_pu, VIENNA_iL3Meas_pu, VIENNA_iPV1Meas_pu, VIENNA_iPV2Meas_pu, VIENNA_vPV1Meas_pu, VIENNA_vPV2Meas_pu, VIENNA_vDCMeas_pu, VIENNA_vCCMeas_pu, VIENNA_TEMPMeas_pu, VIENNA_POTMeas_pu;
//
// Inductor Current Measurement Offset
//
//extern volatile float32_t VIENNA_iL1MeasOffset_pu, VIENNA_iL2MeasOffset_pu,
//                          VIENNA_iL3MeasOffset_pu;
extern volatile float32_t VIENNA_iL1MeasOffset_pu, VIENNA_iL2MeasOffset_pu, VIENNA_iL3MeasOffset_pu,
                   VIENNA_iPV1MeasOffset_pu, VIENNA_iPV2MeasOffset_pu, VIENNA_vPV1MeasOffset_pu, VIENNA_vPV2MeasOffset_pu, VIENNA_vDCMeasOffset_pu;

/*
//
// Output Voltage Bus measurement
//
extern volatile float32_t VIENNA_vBusMNMeas_pu, VIENNA_vBusPMMeas_pu, VIENNA_vBusMeas_pu,
                          VIENNA_vBusHalfMeas_pu;
extern volatile float32_t VIENNA_vBusMNMeasAvg_pu, VIENNA_vBusPMMeasAvg_pu,
                          VIENNA_vBusMeasAvg_pu;

//
// variables used for calibration of output voltage measurements
//
extern volatile float32_t VIENNA_m_VBusMNMeas_pu, VIENNA_b_VBusMNMeas_pu;
extern volatile float32_t VIENNA_m_VBusPMMeas_pu, VIENNA_b_VBusPMMeas_pu;

//
// Input Grid Voltage Measurement
//
extern volatile float32_t VIENNA_v1Meas_pu, VIENNA_v2Meas_pu, VIENNA_v3Meas_pu;
extern volatile float32_t VIENNA_v1MeasOffset_pu, VIENNA_v2MeasOffset_pu,
                          VIENNA_v3MeasOffset_pu;

extern volatile float32_t VIENNA_vRmsMeasAvg_pu;
*/

//
// Variables used to calibrate measurement offsets
//
extern float32_t VIENNA_k1, VIENNA_k2, VIENNA_offset165;

/*
//
// Display Values
//
extern volatile float32_t  VIENNA_guiVbusMN_Volts, VIENNA_guiVbusPM_Volts, VIENNA_guiVbus_Volts,
    VIENNA_guiV1_Volts, VIENNA_guiV2_Volts, VIENNA_guiV3_Volts,
    VIENNA_guiIL1_Amps, VIENNA_guiIL2_Amps, VIENNA_guiIL3_Amps,
    VIENNA_guiIL1sd_Amps, VIENNA_guiIL2sd_Amps, VIENNA_guiIL3sd_Amps;

extern volatile float32_t VIENNA_guiACFreq_Hz;
extern volatile float32_t VIENNA_guiPrms1_W, VIENNA_guiPrms2_W, VIENNA_guiPrms3_W,
                VIENNA_guiPrmsTotal_W;
extern volatile float32_t VIENNA_guiIrms1_Amps, VIENNA_guiIrms2_Amps, VIENNA_guiIrms3_Amps;
extern volatile float32_t VIENNA_guiVrms1_Volts, VIENNA_guiVrms2_Volts, VIENNA_guiVrms3_Volts;
extern volatile float32_t VIENNA_guiPF1, VIENNA_guiPF2, VIENNA_guiPF3;
extern volatile float32_t VIENNA_guiVA1_VA, VIENNA_guiVA2_VA, VIENNA_guiVA3_VA;

extern float32_t VIENNA_guiVbusTripLimit_Volts;

extern uint16_t VIENNA_guiPowerStageStart;
extern uint16_t VIENNA_guiPowerStageStop;
*/

/*
//
// PFC Filtered DC bus measurement
//
extern volatile float32_t VIENNA_vBusAvg_pu;

extern volatile float32_t VIENNA_iL1_CalibrationGain;
extern volatile float32_t VIENNA_iL2_CalibrationGain;
extern volatile float32_t VIENNA_iL3_CalibrationGain;

//
// variables for third harmmonic injection
//
extern volatile float32_t VIENNA_vMin_pu, VIENNA_vMax_pu;
extern volatile float32_t VIENNA_thirdHarmonicInjection;
*/

//
// individual duty cycles for each phase
//
extern volatile float32_t VIENNA_duty1PU, VIENNA_duty2PU, VIENNA_duty3PU;
extern volatile float32_t VIENNA_dutyPU_DC;

/*
//
// Flags for clearing trips and closing the loops
//
extern int16_t VIENNA_closeGiLoop, VIENNA_closeGvLoop, VIENNA_closeGsLoop,
               VIENNA_clearTrip, VIENNA_firstTimeGvLoop;

extern volatile int16_t VIENNA_thirdHarmonicInjectionEnable;

extern volatile float32_t VIENNA_iL1Ref_prev_pu, VIENNA_iL2Ref_prev_pu,
                          VIENNA_iL3Ref_prev_pu;
extern volatile float32_t VIENNA_inductor_voltage_drop_feedforward1,
                          VIENNA_inductor_voltage_drop_feedforward2,
                          VIENNA_inductor_voltage_drop_feedforward3;

extern volatile uint16_t VIENNA_busVoltageSlew;
*/

//
//-----------------------------------------------------------------------------
// Enum for build level of software and board status
//
extern enum VIENNA_BuildLevel_enum VIENNA_buildInfo;

extern enum VIENNA_boardState_enum VIENNA_boardState;

//extern enum VIENNA_boardStatus_enum VIENNA_boardStatus;

//---

enum STATE {VDC_CHARGING=0, IDLE_STATE1=1, SLEW_CONTROL1=2, VPV_CONTROL1=3, DEACCELERATION1=4, IDLE_STATE2=5, SLEW_CONTROL2=6, VPV_CONTROL2=7, DEACCELERATION2=8, FAULT_STATE=9};


//struct COMMON_VARS {
    extern volatile float32_t common_vars_vpv1_ref;
    extern volatile float32_t common_vars_vpv2_ref;
    extern volatile float32_t common_vars_duty1;
    extern volatile float32_t common_vars_duty2;
//};
//#define COMMON_VARS_DEFAULTS {0,0,0,0}

//
//struct COMMON_FLAG {
    extern volatile uint16_t common_flag_clearTripPWM1;
    extern volatile uint16_t common_flag_clearTripPWM2;
//};
//#define COMMON_FLAG_DEFAULTS {0}

//struct IL1_CONTROL_VARS {
    extern volatile float32_t il1_control_ref;
    extern volatile float32_t il1_control_act;
    extern volatile float32_t il1_control_error;
    extern volatile float32_t il1_control_error_prev;
    extern volatile float32_t il1_control_PIout;
    extern volatile float32_t il1_control_feedforward;
    extern volatile float32_t il1_control_controlout;
//};
//#define IL1_CONTROL_VARS_DEFAULTS {0,0,0,0,0,0,0}

//struct IL2_CONTROL_VARS {
    extern volatile float32_t il2_control_ref;
    extern volatile float32_t il2_control_act;
    extern volatile float32_t il2_control_error;
    extern volatile float32_t il2_control_error_prev;
    extern volatile float32_t il2_control_PIout;
    extern volatile float32_t il2_control_feedforward;
    extern volatile float32_t il2_control_controlout;
//};
//#define IL2_CONTROL_VARS_DEFAULTS {0,0,0,0,0,0,0}

//struct VPV1_CONTROL_VARS {
    extern volatile float32_t vpv1_control_ref;
    extern volatile float32_t vpv1_control_act;
    extern volatile float32_t vpv1_control_error;
    extern volatile float32_t vpv1_control_error_prev;
    extern volatile float32_t vpv1_control_PIout;
    extern volatile float32_t vpv1_control_feedforward;
    extern volatile float32_t vpv1_control_controlout;
//};
//#define VPV1_CONTROL_VARS_DEFAULTS {0,0,0,0,0,0,0}

//struct VPV2_CONTROL_VARS {
    extern volatile float32_t vpv2_control_ref;
    extern volatile float32_t vpv2_control_act;
    extern volatile float32_t vpv2_control_error;
    extern volatile float32_t vpv2_control_error_prev;
    extern volatile float32_t vpv2_control_PIout;
    extern volatile float32_t vpv2_control_feedforward;
    extern volatile float32_t vpv2_control_controlout;
//};
//#define VPV2_CONTROL_VARS_DEFAULTS {0,0,0,0,0,0,0}

//struct UPDATE_CONST {
    extern volatile float32_t update_const_k1_PIiL1;
    extern volatile float32_t update_const_k2_PIiL1;
    extern volatile float32_t update_const_k1_PIiL2;
    extern volatile float32_t update_const_k2_PIiL2;
    extern volatile float32_t update_const_upper_limit_il1_PIout;
    extern volatile float32_t update_const_lower_limit_il1_PIout;
    extern volatile float32_t update_const_upper_limit_il2_PIout;
    extern volatile float32_t update_const_lower_limit_il2_PIout;
    extern volatile float32_t update_const_upper_limit_il1_controlout;
    extern volatile float32_t update_const_lower_limit_il1_controlout;
    extern volatile float32_t update_const_upper_limit_il2_controlout;
    extern volatile float32_t update_const_lower_limit_il2_controlout;
    extern volatile float32_t update_const_k1_PIvpv1;
    extern volatile float32_t update_const_k2_PIvpv1;
    extern volatile float32_t update_const_k1_PIvpv2;
    extern volatile float32_t update_const_k2_PIvpv2;
    extern volatile float32_t update_const_upper_limit_vpv1_PIout;
    extern volatile float32_t update_const_lower_limit_vpv1_PIout;
    extern volatile float32_t update_const_upper_limit_vpv2_PIout;
    extern volatile float32_t update_const_lower_limit_vpv2_PIout;
    extern volatile float32_t update_const_upper_limit_vpv1_controlout;
    extern volatile float32_t update_const_lower_limit_vpv1_controlout;
    extern volatile float32_t update_const_upper_limit_vpv2_controlout;
    extern volatile float32_t update_const_lower_limit_vpv2_controlout;
    extern volatile float32_t update_const_ipv1_ref_isc;
    extern volatile float32_t update_const_vpv1_ref_vsc;
    extern volatile float32_t update_const_vpv1_ref_voc;
    extern volatile float32_t update_const_ipv1_ref_imp;
    extern volatile float32_t update_const_slop1_vpv1_ref_gen;
    extern volatile float32_t update_const_constant1_vpv1_ref_gen;
    extern volatile float32_t update_const_slop2_vpv1_ref_gen;
    extern volatile float32_t update_const_constant2_vpv1_ref_gen;
    extern volatile float32_t update_const_ipv2_ref_isc;
    extern volatile float32_t update_const_vpv2_ref_vsc;
    extern volatile float32_t update_const_vpv2_ref_voc;
    extern volatile float32_t update_const_ipv2_ref_imp;
    extern volatile float32_t update_const_slop1_vpv2_ref_gen;
    extern volatile float32_t update_const_constant1_vpv2_ref_gen;
    extern volatile float32_t update_const_slop2_vpv2_ref_gen;
    extern volatile float32_t update_const_constant2_vpv2_ref_gen;
    extern volatile float32_t update_const_slew_rate1;
    extern volatile float32_t update_const_vpv1_threshold_slew_to_vpvcontrol;
    extern volatile float32_t update_const_duty1_threshold_slew_to_vpvcontrol;
    extern volatile float32_t update_const_slew_rate2;
    extern volatile float32_t update_const_vpv2_threshold_slew_to_vpvcontrol;
    extern volatile float32_t update_const_duty2_threshold_slew_to_vpvcontrol;
    extern volatile float32_t update_const_vdc_threshold_charging_to_idle;
    extern volatile float32_t update_const_deacceleration_rate;
    extern volatile float32_t update_const_upper_duty_threshold;
    extern volatile float32_t k1_Fltr_vpv1n2;
    extern volatile float32_t k2_Fltr_vpv1n2;

    extern volatile float32_t Res_flash_init;
    extern volatile float32_t reserved;
    extern volatile float32_t Load_Default_Constants;

//};
//#define UPDATE_CONST_DEFAULTS {31.44,   31.39,  31.44,  31.39,  100,    -100,   100,    -100,   0.7,    0.01,   0.7,    0.01,   0.2364, 0.2349, 0.2364, 0.2349, 25, -25,    25, -25,    25, -25,    25, -25,    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0.00002,    112,    0.2,    0.00002,    112,    0.2,    500,    0.00002,    0}

    extern volatile float32_t update_const_vpv_overvoltage_threshold;

//struct SENSOR {
    extern volatile float32_t sensor_v_pv1;
    extern volatile float32_t sensor_v_pv2;
    extern volatile float32_t sensor_i_pv1;
    extern volatile float32_t sensor_i_pv2;
    extern volatile float32_t sensor_v_dc;
    extern volatile float32_t sensor_i_dc;
    extern volatile float32_t sensor_i_L1;
    extern volatile float32_t sensor_i_L2;
    extern volatile float32_t sensor_v_dc_fltr;
    extern volatile float32_t sensor_v_dc_prev;
    extern volatile float32_t sensor_v_pv1_fltr;
    extern volatile float32_t sensor_v_pv2_fltr;
    extern volatile float32_t sensor_v_pv1_prev;
    extern volatile float32_t sensor_v_pv2_prev;
    extern volatile float32_t sensor_i_pv1_fltr;
    extern volatile float32_t sensor_i_pv2_fltr;
    extern volatile float32_t sensor_i_pv1_prev;
    extern volatile float32_t sensor_i_pv2_prev;
    extern volatile float32_t sensor_i_L1_fltr;
    extern volatile float32_t sensor_i_L2_fltr;
    extern volatile float32_t sensor_i_L1_prev;
    extern volatile float32_t sensor_i_L2_prev;
    extern volatile float32_t sensor_temperature;
    extern volatile float32_t sensor_temperature_fltr;
    extern volatile float32_t sensor_temperature_prev;
    extern volatile float32_t sensor_board_temp;
    extern volatile float32_t sensor_board_temp_fltr;
    extern volatile float32_t sensor_board_temp_prev;
    extern volatile float32_t sensor_ref_vcc;
    extern volatile float32_t sensor_ref_vcc_fltr;
    extern volatile float32_t sensor_ref_vcc_prev;
    extern volatile float32_t sensor_zero_current_offset;
    extern volatile float32_t sensor_ppv;
    extern volatile float32_t sensor_ppv1;
    extern volatile float32_t sensor_ppv2;
//};

//#define SENSOR_DEFAULTS {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}

    extern volatile uint16_t command_OnOffCh1;
    extern volatile uint16_t command_OnOffCh2;
    extern volatile uint16_t command_Clear_OCfault;

    extern volatile uint16_t CONTROL_STATE;
    extern volatile uint16_t CONTROL_STATE2;
    extern volatile uint32_t count_charging4;
    extern volatile uint16_t common_flag_init_GlobalVariable;
//    extern volatile uint32_t testing_variable;
    extern volatile uint16_t VIENNA_boardStatus;

    enum PVcurvesCh1 {Ch1Isc20Voc360Ipv16=0, Ch1P300Ns8Np2Bv045=1, Ch1P300Ns8Np1Bv045=2, Ch1P300Ns9Np2Bv045=3, Ch1P300Ns9Np1Bv045=4, Ch1P300Ns10Np2Bv045=5, Ch1P300Ns10Np1Bv045=6, Ch1P300Ns11Np2Bv045=7, Ch1P300Ns11Np1Bv045=8, Ch1P300Ns12Np2Bv045=9, Ch1P300Ns12Np1Bv045=10, Ch1constant_vpv=11};
    enum PVcurvesCh2 {Ch2Isc20Voc360Ipv16=0, Ch2P300Ns8Np2Bv045=1, Ch2P300Ns8Np1Bv045=2, Ch2P300Ns9Np2Bv045=3, Ch2P300Ns9Np1Bv045=4, Ch2P300Ns10Np2Bv045=5, Ch2P300Ns10Np1Bv045=6, Ch2P300Ns11Np2Bv045=7, Ch2P300Ns11Np1Bv045=8, Ch2P300Ns12Np2Bv045=9, Ch2P300Ns12Np1Bv045=10, Ch2constant_vpv=11};

    extern volatile float32_t Select_PVcurve1;
    extern volatile float32_t Select_PVcurve2;

    extern volatile float32_t vpv_ref1;
    extern volatile float32_t Temp1;
    extern volatile float32_t BetaV1;
    extern volatile float32_t Ns1;
    extern volatile float32_t Np1;
    extern volatile float32_t ILight1;
    extern volatile float32_t ipv1;
    extern volatile float32_t Np1;
    extern volatile float32_t Io1;
    extern volatile float32_t Rs1;
    extern volatile float32_t Nscell1;
    extern volatile float32_t ppv_ref1;

    extern volatile float32_t vpv_ref2;
    extern volatile float32_t Temp2;
    extern volatile float32_t BetaV2;
    extern volatile float32_t Ns2;
    extern volatile float32_t Np2;
    extern volatile float32_t ILight2;
    extern volatile float32_t ipv2;
    extern volatile float32_t Np2;
    extern volatile float32_t Io2;
    extern volatile float32_t Rs2;
    extern volatile float32_t Nscell2;
    extern volatile float32_t ppv_ref2;
    extern volatile float32_t vpv_ref1_fltr_prev;
    extern volatile float32_t vpv_ref1_fltr;
    extern volatile float32_t vpv_ref2_fltr_prev;
    extern volatile float32_t vpv_ref2_fltr;

//---

#ifndef __TMS320C28XX_CLA__

//
// datalogger
//
extern DLOG_4CH VIENNA_dLog1;
extern float32_t VIENNA_dBuff1[100], VIENNA_dBuff2[100], VIENNA_dBuff3[100],
                 VIENNA_dBuff4[100];
extern float32_t VIENNA_dVal1, VIENNA_dVal2, VIENNA_dVal3, VIENNA_dVal4;

//
//--- SFRA Related Variables ----
//
extern float32_t VIENNA_plantMagVect[VIENNA_SFRA_FREQ_LENGTH];
extern float32_t VIENNA_plantPhaseVect[VIENNA_SFRA_FREQ_LENGTH];
extern float32_t VIENNA_olMagVect[VIENNA_SFRA_FREQ_LENGTH];
extern float32_t VIENNA_olPhaseVect[VIENNA_SFRA_FREQ_LENGTH];
extern float32_t VIENNA_freqVect[VIENNA_SFRA_FREQ_LENGTH];

extern SFRA_F32 VIENNA_sfra1;
#endif

//
//*********************** the function prototypes *************************
//

#ifndef __TMS320C28XX_CLA__
   extern void VIENNA_setupSFRA();
   extern void VIENNA_runSFRABackGroundTasks();
   extern void VIENNA_updateBoardStatus(void);
   extern void VIENNA_globalVariablesInit(void);
   extern void initGlobalVariable(void);
   extern void VIENNA_calibrateOffset(void);
#else

#endif

extern uint16_t Screen_count;
//extern enum LCD_STATE;

extern volatile double xx;

/*
#pragma FUNC_ALWAYS_INLINE(VIENNA_readCurrVolADCSignals)

//
// readCurrVolADCSignals()
//
static inline void VIENNA_readCurrVolADCSignals(void)
{

    VIENNA_iL1Meas_pu = (((float32_t)(VIENNA_IL1_FB_1 + VIENNA_IL1_FB_2 +
            VIENNA_IL1_FB_3 + VIENNA_IL1_FB_4)) *
            VIENNA_ADC_PU_SCALE_FACTOR * 0.25f - VIENNA_iL1MeasOffset_pu ) * 2.0f;
    VIENNA_iL2Meas_pu = (((float32_t)(VIENNA_IL2_FB_1 + VIENNA_IL2_FB_2 +
            VIENNA_IL2_FB_3 + VIENNA_IL2_FB_4)) *
            VIENNA_ADC_PU_SCALE_FACTOR * 0.25f - VIENNA_iL2MeasOffset_pu ) * 2.0f;

    VIENNA_iL3Meas_pu = (((float32_t)(VIENNA_IL3_FB_1 + VIENNA_IL3_FB_2 +
            VIENNA_IL3_FB_3 + VIENNA_IL3_FB_4)) *
            VIENNA_ADC_PU_SCALE_FACTOR * 0.25f - VIENNA_iL3MeasOffset_pu ) * 2.0f;


    VIENNA_v1Meas_pu = (((float32_t)(VIENNA_V1_FB_1 + VIENNA_V1_FB_2 +
            VIENNA_V1_FB_3 + VIENNA_V1_FB_4)) *
            VIENNA_ADC_PU_SCALE_FACTOR * 0.25f - VIENNA_v1MeasOffset_pu ) * 2.0f;
    VIENNA_v2Meas_pu = (((float32_t)(VIENNA_V2_FB_1 + VIENNA_V2_FB_2 +
            VIENNA_V2_FB_3 + VIENNA_V2_FB_4)) *
            VIENNA_ADC_PU_SCALE_FACTOR * 0.25f - VIENNA_v2MeasOffset_pu ) * 2.0f;
    VIENNA_v3Meas_pu = (((float32_t)(VIENNA_V3_FB_1 + VIENNA_V3_FB_2 +
            VIENNA_V3_FB_3 + VIENNA_V3_FB_4)) *
            VIENNA_ADC_PU_SCALE_FACTOR * 0.25f - VIENNA_v3MeasOffset_pu ) * 2.0f;

    VIENNA_vBusPMMeas_pu = (((float32_t)(VIENNA_VBUSPM_FB_1 + VIENNA_VBUSPM_FB_2
                         + VIENNA_VBUSPM_FB_3 + VIENNA_VBUSPM_FB_4)) *
            VIENNA_ADC_PU_SCALE_FACTOR * 0.25f ) *
                    VIENNA_VDCBUS_MAX_SENSE_VOLTS / VIENNA_VAC_MAX_SENSE_VOLTS;
    VIENNA_vBusMNMeas_pu = (((float32_t)(VIENNA_VBUSMN_FB_1 + VIENNA_VBUSMN_FB_2
                         + VIENNA_VBUSMN_FB_3 + VIENNA_VBUSMN_FB_4)) *
            VIENNA_ADC_PU_SCALE_FACTOR * 0.25f ) *
                    VIENNA_VDCBUS_MAX_SENSE_VOLTS / VIENNA_VAC_MAX_SENSE_VOLTS;

    //
    // y = mx+ b equation used to reduce offset and gain error
    //
    VIENNA_vBusPMMeas_pu = VIENNA_m_VBusPMMeas_pu * VIENNA_vBusPMMeas_pu +
                        VIENNA_b_VBusPMMeas_pu;
    VIENNA_vBusMNMeas_pu = VIENNA_m_VBusMNMeas_pu * VIENNA_vBusMNMeas_pu +
                        VIENNA_b_VBusMNMeas_pu;

    VIENNA_vBusMeas_pu = VIENNA_vBusPMMeas_pu + VIENNA_vBusMNMeas_pu;
    VIENNA_vBusHalfMeas_pu = (VIENNA_vBusMeas_pu) * 0.5f;

    //
    // clamp the vBusHalfMeas before dividing to avoid NaN
    //
    VIENNA_vBusHalfMeas_pu = (VIENNA_vBusHalfMeas_pu < 0.2f)?0.2f:VIENNA_vBusHalfMeas_pu;
}
*/

//
// readCurrVolSDFMSignals()
//
static inline void VIENNA_readCurrVolSDFMSignals(float32_t sdfm_scale_factor)
{

    VIENNA_iL1MeasSD_pu = (float32_t)( ( (int32_t)
                       SDFM_getFilterData(VIENNA_IL1_SDFM_BASE,
                       VIENNA_IL1_SDFM_FILTER)) * VIENNA_SD32_PU_SCALE_FACTOR);

    VIENNA_iL2MeasSD_pu = (float32_t)( ( (int32_t)
                       SDFM_getFilterData(VIENNA_IL2_SDFM_BASE,
                       VIENNA_IL2_SDFM_FILTER)) * VIENNA_SD32_PU_SCALE_FACTOR);

    VIENNA_iL3MeasSD_pu = (float32_t)( ( (int32_t)
                       SDFM_getFilterData(VIENNA_IL3_SDFM_BASE,
                       VIENNA_IL3_SDFM_FILTER)) * VIENNA_SD32_PU_SCALE_FACTOR);

    VIENNA_iL1Meas_pu = VIENNA_iL1MeasSD_pu *
                     (VIENNA_I_MAX_SENSE_SD_AMPS / VIENNA_I_MAX_SENSE_AMPS);
    VIENNA_iL2Meas_pu = VIENNA_iL2MeasSD_pu * (VIENNA_I_MAX_SENSE_SD_AMPS /
                     VIENNA_I_MAX_SENSE_AMPS);
    VIENNA_iL3Meas_pu = VIENNA_iL3MeasSD_pu * (VIENNA_I_MAX_SENSE_SD_AMPS /
                     VIENNA_I_MAX_SENSE_AMPS);
}

/*
//
// clearPWMTrip()
//
static inline void VIENNA_clearPWMTrip()
{
    if(common_flag_clearTripPWM1 == 1)
    {
        //
        // clear all the configured trip sources for the PWM module
        EPWM_clearTripZoneFlag(EPWM1_BASE, (EPWM_TZ_INTERRUPT_OST | EPWM_TZ_INTERRUPT_CBC | EPWM_TZ_INTERRUPT_DCAEVT1 | EPWM_TZ_INTERRUPT_DCBEVT1) );
        EPWM_clearTripZoneFlag(EPWM2_BASE, (EPWM_TZ_INTERRUPT_OST | EPWM_TZ_INTERRUPT_CBC | EPWM_TZ_INTERRUPT_DCAEVT1 | EPWM_TZ_INTERRUPT_DCBEVT1) );
        EPWM_clearTripZoneFlag(EPWM3_BASE, (EPWM_TZ_INTERRUPT_OST | EPWM_TZ_INTERRUPT_CBC | EPWM_TZ_INTERRUPT_DCAEVT1 | EPWM_TZ_INTERRUPT_DCBEVT1) );

        CMPSS_clearFilterLatchHigh(CMPSS1_BASE);
        CMPSS_clearFilterLatchLow(CMPSS1_BASE);
        CMPSS_clearFilterLatchHigh(CMPSS2_BASE);
        CMPSS_clearFilterLatchLow(CMPSS2_BASE);
        CMPSS_clearFilterLatchHigh(CMPSS5_BASE);
        CMPSS_clearFilterLatchLow(CMPSS5_BASE);

        common_flag_clearTripPWM1 = 0;
        resetDISABLE_PWM1();
        resetDISABLE_PWM2();
    }
}
*/

#pragma FUNC_ALWAYS_INLINE(clearPWM1Trip)
static inline void clearPWM1Trip(void)
{
    if(common_flag_clearTripPWM1 == 1)
    {
        //
        // clear all the configured trip sources for the PWM module
        EPWM_clearTripZoneFlag(EPWM1_BASE, (EPWM_TZ_INTERRUPT_OST | EPWM_TZ_INTERRUPT_CBC | EPWM_TZ_INTERRUPT_DCAEVT1 | EPWM_TZ_INTERRUPT_DCBEVT1) );
//        EPWM_clearTripZoneFlag(EPWM2_BASE, (EPWM_TZ_INTERRUPT_OST | EPWM_TZ_INTERRUPT_CBC | EPWM_TZ_INTERRUPT_DCAEVT1 | EPWM_TZ_INTERRUPT_DCBEVT1) );
//        EPWM_clearTripZoneFlag(EPWM3_BASE, (EPWM_TZ_INTERRUPT_OST | EPWM_TZ_INTERRUPT_CBC | EPWM_TZ_INTERRUPT_DCAEVT1 | EPWM_TZ_INTERRUPT_DCBEVT1) );

        CMPSS_clearFilterLatchHigh(CMPSS1_BASE);
        CMPSS_clearFilterLatchLow(CMPSS1_BASE);
//        CMPSS_clearFilterLatchHigh(CMPSS2_BASE);
//        CMPSS_clearFilterLatchLow(CMPSS2_BASE);
//        CMPSS_clearFilterLatchHigh(CMPSS5_BASE);
//        CMPSS_clearFilterLatchLow(CMPSS5_BASE);

        common_flag_clearTripPWM1 = 0;
        //DisablePWM = CLEAR;
        resetDISABLE_PWM1();
//        resetDISABLE_PWM2();
    }
}

#pragma FUNC_ALWAYS_INLINE(clearPWM2Trip)
static inline void clearPWM2Trip(void)
{
    if(common_flag_clearTripPWM2 == 1)
    {
        //
        // clear all the configured trip sources for the PWM module
//        EPWM_clearTripZoneFlag(EPWM1_BASE, (EPWM_TZ_INTERRUPT_OST | EPWM_TZ_INTERRUPT_CBC | EPWM_TZ_INTERRUPT_DCAEVT1 | EPWM_TZ_INTERRUPT_DCBEVT1) );
        EPWM_clearTripZoneFlag(EPWM2_BASE, (EPWM_TZ_INTERRUPT_OST | EPWM_TZ_INTERRUPT_CBC | EPWM_TZ_INTERRUPT_DCAEVT1 | EPWM_TZ_INTERRUPT_DCBEVT1) );
//        EPWM_clearTripZoneFlag(EPWM3_BASE, (EPWM_TZ_INTERRUPT_OST | EPWM_TZ_INTERRUPT_CBC | EPWM_TZ_INTERRUPT_DCAEVT1 | EPWM_TZ_INTERRUPT_DCBEVT1) );

//        CMPSS_clearFilterLatchHigh(CMPSS1_BASE);
//        CMPSS_clearFilterLatchLow(CMPSS1_BASE);
        CMPSS_clearFilterLatchHigh(CMPSS2_BASE);
        CMPSS_clearFilterLatchLow(CMPSS2_BASE);
//        CMPSS_clearFilterLatchHigh(CMPSS5_BASE);
//        CMPSS_clearFilterLatchLow(CMPSS5_BASE);

        common_flag_clearTripPWM2 = 0;
        //DisablePWM = CLEAR;
//        resetDISABLE_PWM1();
        resetDISABLE_PWM2();
    }
}

//==============-------------
#pragma FUNC_ALWAYS_INLINE(Vdc_Charging)
static inline void Vdc_Charging(void)
{
    //Display_screen  "Preparing"  //make it to run only one time

/*
    //Turn OFF Relay
    PowerRelay = OFF;
    DisablePWM = SET;
*/
    resetPOWER_RELAY();
    setDISABLE_PWM1();
    setDISABLE_PWM2();
//    testing_variable = 200;
    count_charging4++;
    if (count_charging4<100000) return;
    count_charging4 = 0;
    if (VIENNA_vDCMeas_pu > update_const_vdc_threshold_charging_to_idle) {
        //Release Display_screen from  "Preparing"
        //Turn ON Relay
/*        PowerRelay = ON;*/
        setPOWER_RELAY();
        //PowerControl_State_Ptr1 = &Idle_State1;
        //PowerControl_State_Ptr2 = &Idle_State2;
        CONTROL_STATE = IDLE_STATE1;
        CONTROL_STATE2 = IDLE_STATE2;

/*
        if (CONTROL_STATE == IDLE_STATE1) {
            testing_variable = 100;
        }
*/
    }

}

#pragma FUNC_ALWAYS_INLINE(Idle_State1)
static inline void Idle_State1(void)
{
/*    if (!DisablePWM) DisablePWM = SET;*/
    setDISABLE_PWM1();
    if ( (command_OnOffCh1) && (VIENNA_vDCMeas_pu > update_const_vdc_threshold_charging_to_idle)) {
/*        PowerRelay = ON;*/
        setPOWER_RELAY();
        //PowerControl_State_Ptr1 = &Slew_Control1;
        CONTROL_STATE = SLEW_CONTROL1;
        common_flag_clearTripPWM1 = 1;

/*
        EALLOW;
        EPwm1Regs.TZCLR.bit.OST = 1; //only for testing
        EDIS;
*/

    }
}

#pragma FUNC_ALWAYS_INLINE(Slew_Control1)
static inline void Slew_Control1(void)
{
    clearPWM1Trip();
    common_vars_duty1 =common_vars_duty1+update_const_slew_rate1;

    if ((sensor_v_pv1_fltr > update_const_vpv1_threshold_slew_to_vpvcontrol) || (common_vars_duty1 >= update_const_duty1_threshold_slew_to_vpvcontrol)) {
        il1_control_ref = il1_control_act;
        il1_control_error_prev = 0.0;
        il1_control_PIout = 0.0; //inductor.d_iL = 5600*(pwm.boost_duty - GAIN_1_MINUS_D_BY_VDCO * sensors.v_dc_fltr);  //exact initial value
        vpv1_control_ref = vpv1_control_act;
        vpv1_control_error_prev = 0.0;
        vpv1_control_PIout = 0.0; // ???
        //PowerControl_State_Ptr1 = &Vpv_Control1;
        CONTROL_STATE = VPV_CONTROL1;
    }
}

#pragma FUNC_ALWAYS_INLINE(buck1_current_control)
static inline void buck1_current_control(void)
{
    il1_control_ref = vpv1_control_controlout;
    il1_control_error = il1_control_ref - VIENNA_iL1Meas_pu;
//    il1_control.error = 2.0 - VIENNA_iL1Meas_pu; //for TESTING ONLY
//    il1_control.PIout = il1_control.PIout + update_const.k1_PIiL1 * il1_control.error + update_const.k2_PIiL1 * il1_control.error_prev;
    il1_control_PIout = il1_control_PIout + update_const_k1_PIiL1 * il1_control_error - update_const_k2_PIiL1 * il1_control_error_prev;
    if(il1_control_PIout > update_const_upper_limit_il1_PIout) il1_control_PIout = update_const_upper_limit_il1_PIout;
    else if(il1_control_PIout < update_const_lower_limit_il1_PIout) il1_control_PIout = update_const_lower_limit_il1_PIout;
    il1_control_error_prev = il1_control_error;
//    il1_control.controlout = GAIN_R_BY_VDCO * il1_control.PIout + GAIN_1_MINUS_D_BY_VDCO * VIENNA_vDCMeas_pu;
    il1_control_controlout = ( il1_control_PIout + VIENNA_vPV1Meas_pu ) / VIENNA_vDCMeas_pu;
    if(il1_control_controlout > update_const_upper_limit_il1_controlout) il1_control_controlout = update_const_upper_limit_il1_controlout;
    else if(il1_control_controlout < update_const_lower_limit_il1_controlout) il1_control_controlout = update_const_lower_limit_il1_controlout;
    common_vars_duty1 = il1_control_controlout;
}

#pragma FUNC_ALWAYS_INLINE(buck1pv_voltage_control)
static inline void buck1pv_voltage_control(void)
{
    common_vars_vpv1_ref = 100.0; //FOR TESTING ONLY
    vpv1_control_ref = common_vars_vpv1_ref;
    vpv1_control_error = vpv1_control_ref - VIENNA_vPV1Meas_pu;
    vpv1_control_PIout = vpv1_control_PIout + update_const_k1_PIvpv1 * vpv1_control_error - update_const_k2_PIvpv1 * vpv1_control_error_prev;
    if(vpv1_control_PIout > update_const_upper_limit_vpv1_PIout) vpv1_control_PIout = update_const_upper_limit_vpv1_PIout;
    else if(vpv1_control_PIout < update_const_lower_limit_vpv1_PIout) vpv1_control_PIout = update_const_lower_limit_vpv1_PIout;
    vpv1_control_error_prev = vpv1_control_error;
//    vpv1_control.controlout = vpv1_control.PIout;
//    vpv1_control.controlout = VIENNA_iPV1Meas_pu + vpv1_control.PIout;
    vpv1_control_controlout = sensor_i_pv1_fltr + vpv1_control_PIout;
    if(vpv1_control_controlout > update_const_upper_limit_vpv1_controlout) vpv1_control_controlout = update_const_upper_limit_vpv1_controlout;
    else if(vpv1_control_controlout < update_const_lower_limit_vpv1_controlout) vpv1_control_controlout = update_const_lower_limit_vpv1_controlout;
}

#pragma FUNC_ALWAYS_INLINE(vpv_ref1_generation)
static inline void vpv_ref1_generation(void)
{
    switch ((uint16_t)Select_PVcurve1) {
                case Ch1Isc20Voc360Ipv16:
                    update_const_ipv1_ref_isc = 20.0;
                    update_const_vpv1_ref_vsc = 0.0;
                    update_const_vpv1_ref_voc = 360.0;
                    update_const_ipv1_ref_imp = 16.0;
                    update_const_slop1_vpv1_ref_gen = 65.0;
                    update_const_constant1_vpv1_ref_gen = 1300.0;
                    update_const_slop2_vpv1_ref_gen = 6.25;
                    update_const_constant2_vpv1_ref_gen = 360.0;


                    if (sensor_i_pv1_fltr>update_const_ipv1_ref_isc) {
                        common_vars_vpv1_ref = update_const_vpv1_ref_vsc;
                    }
                    else if (sensor_i_pv1_fltr<0.0) {
                        common_vars_vpv1_ref = update_const_vpv1_ref_voc;
                    }
                    else if (sensor_i_pv1_fltr>update_const_ipv1_ref_imp) {
                        common_vars_vpv1_ref = -update_const_slop1_vpv1_ref_gen*sensor_i_pv1_fltr+update_const_constant1_vpv1_ref_gen;
                    }
                    else if (sensor_i_pv1_fltr<=update_const_ipv1_ref_imp) {
                        common_vars_vpv1_ref = -update_const_slop2_vpv1_ref_gen*sensor_i_pv1_fltr+update_const_constant2_vpv1_ref_gen;
                    }
                    break;
                case Ch1P300Ns8Np2Bv045:
                        Ns1=8;
                        Np1=2;
                    break;
                case Ch1P300Ns8Np1Bv045:
                        Ns1=8;
                        Np1=1;
                    break;
                case Ch1P300Ns9Np2Bv045:
                        Ns1=9;
                        Np1=2;
                    break;
                case Ch1P300Ns9Np1Bv045:
                        Ns1=9;
                        Np1=1;
                    break;
                case Ch1P300Ns10Np2Bv045:
                        Ns1=10;
                        Np1=2;
                    break;
                case Ch1P300Ns10Np1Bv045:
                        Ns1=10;
                        Np1=1;
                    break;
                case Ch1P300Ns11Np2Bv045:
                        Ns1=11;
                        Np1=2;
                    break;
                case Ch1P300Ns11Np1Bv045:
                        Ns1=11;
                        Np1=1;
                    break;
                default:
                    break;
    }

    if(((uint16_t)Select_PVcurve1!=Ch1Isc20Voc360Ipv16) && ((uint16_t)Select_PVcurve1!=Ch1constant_vpv)) {
        ipv1=sensor_i_pv1_fltr;

        if (ipv1>ILight1*Np1) ipv1=ILight1*Np1;

        #if VIENNA_CONTROL_RUNNING_ON == C28x_CORE
        vpv_ref1 = (1-(Temp1-25)*BetaV1/100)*( (1.8146*Ns1)*logf(  (Np1*ILight1-ipv1) /(Np1*Io1*0.000001) +1  ) - Ns1*Rs1*ipv1 );
        #endif

        #if VIENNA_CONTROL_RUNNING_ON == CLA_CORE
        vpv_ref1 = (1-(Temp1-25)*BetaV1/100)*( (1.8146*Ns1)*logf(  (Np1*ILight1-ipv1) /(Np1*Io1*0.000001) +1  ) - Ns1*Rs1*ipv1 );
        #endif

/*
        if (vpv_ref1 > ((1-(Temp1-25)*BetaV1/100)*Ns1*45.78)){
            vpv_ref1 = ((1-(Temp1-25)*BetaV1/100)*Ns1*45.78);
        }
*/
        if (vpv_ref1 > ((1-(Temp1-25)*BetaV1/100)*Ns1*(float32_t)45.78) ){
            vpv_ref1 = ((1-(Temp1-25)*BetaV1/100)*Ns1*(float32_t)45.78);
        }
        if (vpv_ref1<0.0) vpv_ref1=0.0;
    }
    vpv_ref1_fltr = k1_Fltr_vpv1n2 * vpv_ref1_fltr+ k2_Fltr_vpv1n2 * (vpv_ref1 + vpv_ref1_fltr_prev); //Tf=1/(2pi50) 50=fsw/(10x10x10)
    vpv_ref1_fltr_prev = vpv_ref1_fltr;

    common_vars_vpv1_ref = vpv_ref1_fltr;
//    common_vars_vpv1_ref = 100.0; //for testing purpose only
    ppv_ref1 = vpv_ref1_fltr*ipv1;
}


#pragma FUNC_ALWAYS_INLINE(Vpv_Control1)
static inline void Vpv_Control1(void)
{   //vpv control takes 3.6usec
    buck1_current_control();
    buck1pv_voltage_control();
    vpv_ref1_generation();
//    clearPWMTrip();

//    common_vars.duty1 = 0.01*(float)Constant;//FOR TESTING ONLY


    if (!command_OnOffCh1) {
//        PowerControl_State_Ptr1 = &Deacceleration1;
        CONTROL_STATE = DEACCELERATION1;
    }
}

#pragma FUNC_ALWAYS_INLINE(Deacceleration1)
static inline void Deacceleration1(void)
{
    common_vars_duty1 = common_vars_duty1-update_const_deacceleration_rate;

    if (common_vars_duty1 <=0.01) {
        common_vars_duty1 = 0.0;
        //screen_change to suitable;
/*        DisablePWM = SET;*/
        //PowerControl_State_Ptr1 = &Idle_State1;
        CONTROL_STATE = IDLE_STATE1;
    }
}

#pragma FUNC_ALWAYS_INLINE(Idle_State2)
static inline void Idle_State2(void)
{
/*    if (!DisablePWM) DisablePWM = SET;*/
    setDISABLE_PWM2();
    if ( (command_OnOffCh2) && (VIENNA_vDCMeas_pu > update_const_vdc_threshold_charging_to_idle)) {
/*        PowerRelay = ON;*/
        setPOWER_RELAY();
        //PowerControl_State_Ptr1 = &Slew_Control1;
        CONTROL_STATE2 = SLEW_CONTROL2;
        common_flag_clearTripPWM2 = 1;

/*
        EALLOW;
        EPwm1Regs.TZCLR.bit.OST = 1; //only for testing
        EDIS;
*/

    }
}

#pragma FUNC_ALWAYS_INLINE(Slew_Control2)
static inline void Slew_Control2(void)
{
    clearPWM2Trip();
    common_vars_duty2 =common_vars_duty2+update_const_slew_rate2;

    if ((sensor_v_pv2_fltr > update_const_vpv2_threshold_slew_to_vpvcontrol) || (common_vars_duty2 >= update_const_duty2_threshold_slew_to_vpvcontrol)) {
        il2_control_ref = il2_control_act;
        il2_control_error_prev = 0.0;
        il2_control_PIout = 0.0; //inductor.d_iL = 5600*(pwm.boost_duty - GAIN_1_MINUS_D_BY_VDCO * sensors.v_dc_fltr);  //exact initial value
        vpv2_control_ref = vpv2_control_act;
        vpv2_control_error_prev = 0.0;
        vpv2_control_PIout = 0.0; // ???
        //PowerControl_State_Ptr1 = &Vpv_Control1;
        CONTROL_STATE2 = VPV_CONTROL2;
    }
}

#pragma FUNC_ALWAYS_INLINE(buck2_current_control)
static inline void buck2_current_control(void)
{
    il2_control_ref = vpv2_control_controlout;
    il2_control_error = il2_control_ref - VIENNA_iL2Meas_pu;
//    il2_control.error = 2.0 - VIENNA_iL1Meas_pu; //for TESTING ONLY
//    il2_control.PIout = il2_control.PIout + update_const.k1_PIiL2 * il2_control.error + update_const.k2_PIiL2 * il2_control.error_prev;
    il2_control_PIout = il2_control_PIout + update_const_k1_PIiL2 * il2_control_error - update_const_k2_PIiL2 * il2_control_error_prev;
    if(il2_control_PIout > update_const_upper_limit_il2_PIout) il2_control_PIout = update_const_upper_limit_il2_PIout;
    else if(il2_control_PIout < update_const_lower_limit_il2_PIout) il2_control_PIout = update_const_lower_limit_il2_PIout;
    il2_control_error_prev = il2_control_error;
//    il2_control.controlout = GAIN_R_BY_VDCO * il2_control.PIout + GAIN_1_MINUS_D_BY_VDCO * VIENNA_vDCMeas_pu;
    il2_control_controlout = ( il2_control_PIout + VIENNA_vPV2Meas_pu ) / VIENNA_vDCMeas_pu;
    if(il2_control_controlout > update_const_upper_limit_il2_controlout) il2_control_controlout = update_const_upper_limit_il2_controlout;
    else if(il2_control_controlout < update_const_lower_limit_il2_controlout) il2_control_controlout = update_const_lower_limit_il2_controlout;
    common_vars_duty2 = il2_control_controlout;
}

#pragma FUNC_ALWAYS_INLINE(buck2pv_voltage_control)
static inline void buck2pv_voltage_control(void)
{
    common_vars_vpv2_ref = 100.0; //FOR TESTING ONLY
    vpv2_control_ref = common_vars_vpv2_ref;
    vpv2_control_error = vpv2_control_ref - VIENNA_vPV2Meas_pu;
    vpv2_control_PIout = vpv2_control_PIout + update_const_k1_PIvpv2 * vpv2_control_error - update_const_k2_PIvpv2 * vpv2_control_error_prev;
    if(vpv2_control_PIout > update_const_upper_limit_vpv2_PIout) vpv2_control_PIout = update_const_upper_limit_vpv2_PIout;
    else if(vpv2_control_PIout < update_const_lower_limit_vpv2_PIout) vpv2_control_PIout = update_const_lower_limit_vpv2_PIout;
    vpv2_control_error_prev = vpv2_control_error;
//    vpv2_control.controlout = vpv2_control.PIout;
//    vpv2_control.controlout = VIENNA_iPV2Meas_pu + vpv2_control.PIout;
    vpv2_control_controlout = sensor_i_pv2_fltr + vpv2_control_PIout;
    if(vpv2_control_controlout > update_const_upper_limit_vpv2_controlout) vpv2_control_controlout = update_const_upper_limit_vpv2_controlout;
    else if(vpv2_control_controlout < update_const_lower_limit_vpv2_controlout) vpv2_control_controlout = update_const_lower_limit_vpv2_controlout;
}

#pragma FUNC_ALWAYS_INLINE(vpv_ref2_generation)
static inline void vpv_ref2_generation(void)
{
    switch ((uint16_t)Select_PVcurve2) {
                case Ch2Isc20Voc360Ipv16:
                    update_const_ipv2_ref_isc = 20.0;
                    update_const_vpv2_ref_vsc = 0.0;
                    update_const_vpv2_ref_voc = 360.0;
                    update_const_ipv2_ref_imp = 16.0;
                    update_const_slop1_vpv2_ref_gen = 65.0;
                    update_const_constant1_vpv2_ref_gen = 1300.0;
                    update_const_slop2_vpv2_ref_gen = 6.25;
                    update_const_constant2_vpv2_ref_gen = 360.0;


                    if (sensor_i_pv2_fltr>update_const_ipv2_ref_isc) {
                        common_vars_vpv2_ref = update_const_vpv2_ref_vsc;
                    }
                    else if (sensor_i_pv2_fltr<0.0) {
                        common_vars_vpv2_ref = update_const_vpv2_ref_voc;
                    }
                    else if (sensor_i_pv2_fltr>update_const_ipv2_ref_imp) {
                        common_vars_vpv2_ref = -update_const_slop1_vpv2_ref_gen*sensor_i_pv2_fltr+update_const_constant1_vpv2_ref_gen;
                    }
                    else if (sensor_i_pv2_fltr<=update_const_ipv2_ref_imp) {
                        common_vars_vpv2_ref = -update_const_slop2_vpv2_ref_gen*sensor_i_pv2_fltr+update_const_constant2_vpv2_ref_gen;
                    }
                    break;
                case Ch2P300Ns8Np2Bv045:
                        Ns2=8;
                        Np2=2;
                    break;
                case Ch2P300Ns8Np1Bv045:
                        Ns2=8;
                        Np2=1;
                    break;
                case Ch2P300Ns9Np2Bv045:
                        Ns2=9;
                        Np2=2;
                    break;
                case Ch2P300Ns9Np1Bv045:
                        Ns2=9;
                        Np2=1;
                    break;
                case Ch2P300Ns10Np2Bv045:
                        Ns2=10;
                        Np2=2;
                    break;
                case Ch2P300Ns10Np1Bv045:
                        Ns2=10;
                        Np2=1;
                    break;
                case Ch2P300Ns11Np2Bv045:
                        Ns2=11;
                        Np2=2;
                    break;
                case Ch2P300Ns11Np1Bv045:
                        Ns2=11;
                        Np2=1;
                    break;
                default:
                    break;
    }

    if(((uint16_t)Select_PVcurve2!=Ch2Isc20Voc360Ipv16) && ((uint16_t)Select_PVcurve2!=Ch2constant_vpv)) {
        ipv2=sensor_i_pv2_fltr;
        if (ipv2>ILight2*Np2) ipv2=ILight2*Np2;

        #if VIENNA_CONTROL_RUNNING_ON == C28x_CORE
        vpv_ref2 = (1+(Temp2-25)*BetaV2/100)*( (1.8146*Ns2)*logf(  (Np2*ILight2-ipv2) /(Np2*Io2*0.000001) +1  ) - Ns2*Rs2*ipv2 );
        #endif

        #if VIENNA_CONTROL_RUNNING_ON == CLA_CORE
        vpv_ref2 = (1+(Temp2-25)*BetaV2/100)*( (1.8146*Ns2)*logf(  (Np2*ILight2-ipv2) /(Np2*Io2*0.000001) +1  ) - Ns2*Rs2*ipv2 );
        #endif

        if (vpv_ref2 > ((1+(Temp2-25)*BetaV2/100)*Ns2*(float32_t)45.78) ){
            vpv_ref2 = ((1+(Temp2-25)*BetaV2/100)*Ns2*(float32_t)45.78);
        }
        if (vpv_ref2<0.0) vpv_ref2=0.0;
    }

    vpv_ref2_fltr = k1_Fltr_vpv1n2 * vpv_ref2_fltr+ k2_Fltr_vpv1n2 * (vpv_ref2 + vpv_ref2_fltr_prev); //Tf=1/(2pi50) 50=fsw/(10x10x10)
    vpv_ref2_fltr_prev = vpv_ref2_fltr;

    common_vars_vpv2_ref = vpv_ref2_fltr;
    ppv_ref2 = vpv_ref2_fltr*ipv2;
}

#pragma FUNC_ALWAYS_INLINE(Vpv_Control2)
static inline void Vpv_Control2(void)
{   //vpv control takes 3.6usec
    buck2_current_control();
    buck2pv_voltage_control();
    vpv_ref2_generation();
//    clearPWMTrip();

//    common_vars.duty1 = 0.01*(float)Constant;//FOR TESTING ONLY


    if (!command_OnOffCh2) {
//        PowerControl_State_Ptr2 = &Deacceleration2;
        CONTROL_STATE2 = DEACCELERATION2;
    }
}

#pragma FUNC_ALWAYS_INLINE(Deacceleration2)
static inline void Deacceleration2(void)
{
    common_vars_duty2 = common_vars_duty2-update_const_deacceleration_rate;

    if (common_vars_duty2 <=0.01) {
        common_vars_duty2 = 0.0;
        //screen_change to suitable;
/*        DisablePWM = SET;*/
        //PowerControl_State_Ptr2 = &Idle_State2;
        CONTROL_STATE2 = IDLE_STATE2;
    }
}

#pragma FUNC_ALWAYS_INLINE(Fault_State)
static inline void Fault_State(void)
{
/*
    //Disable PWM
    if (!DisablePWM) DisablePWM = SET;
    //Turn OFF Relay
    PowerRelay = OFF;
*/
    setDISABLE_PWM1();
    setDISABLE_PWM2();
    resetPOWER_RELAY();

    //Display fault msg

    //Check for problem fix

    if(command_Clear_OCfault) {
        common_flag_init_GlobalVariable=1;
        CONTROL_STATE = VDC_CHARGING;
        CONTROL_STATE2 = VDC_CHARGING;

//        VIENNA_HAL_clearPWMTripFlags(EPWM1_BASE); //For testing only
//        VIENNA_HAL_clearCMPSSLatchFlags(CMPSS3_BASE); //For testing only using POT
    }

/*
    if(command_OnOffCh1) {
        //PowerControl_State_Ptr1 = &Vdc_Charging;
        CONTROL_STATE = VDC_CHARGING;
    }
*/
}

#pragma FUNC_ALWAYS_INLINE(readCurrVolADCSignals)
static inline void readCurrVolADCSignals(void)
{
    VIENNA_iL1Meas_pu = (((float32_t)(VIENNA_IL1_FB_1 + VIENNA_IL1_FB_2 +
            VIENNA_IL1_FB_3 + VIENNA_IL1_FB_4)) *
            (float32_t)ADC_I_GAIN * 0.25f - VIENNA_iL1MeasOffset_pu ) * 2.0f;
    VIENNA_iL2Meas_pu = (((float32_t)(VIENNA_IL2_FB_1 + VIENNA_IL2_FB_2 +
            VIENNA_IL2_FB_3 + VIENNA_IL2_FB_4)) *
            (float32_t)ADC_I_GAIN * 0.25f - VIENNA_iL2MeasOffset_pu ) * 2.0f;

/*
    VIENNA_iPV1Meas_pu = ( ((float32_t)(VIENNA_IPV1_FB_1 + VIENNA_IPV1_FB_2 +
            VIENNA_IPV1_FB_3 + VIENNA_IPV1_FB_4)) *
            (float32_t)ADC_I_GAIN * 0.25 - VIENNA_iPV1MeasOffset_pu )*2.0;
    VIENNA_iPV2Meas_pu = ( ((float32_t)(VIENNA_IPV2_FB_1 + VIENNA_IPV2_FB_2 +
            VIENNA_IPV2_FB_3 + VIENNA_IPV2_FB_4)) *
            (float32_t)ADC_I_GAIN * 0.25 - VIENNA_iPV2MeasOffset_pu )*2.0;

    VIENNA_vPV1Meas_pu = ( ((float32_t)(VIENNA_VPV1_FB_1 + VIENNA_VPV1_FB_2 +
            VIENNA_VPV1_FB_3 + VIENNA_VPV1_FB_4)) *
            (float32_t)ADC_VPV_GAIN * 0.25f - VIENNA_vPV1MeasOffset_pu )*2.0;
    VIENNA_vPV2Meas_pu = ( ((float32_t)(VIENNA_VPV2_FB_1 + VIENNA_VPV2_FB_2 +
            VIENNA_VPV2_FB_3 + VIENNA_VPV2_FB_4)) *
            (float32_t)ADC_VPV_GAIN * 0.25f - VIENNA_vPV2MeasOffset_pu )*2.0;

*/

    VIENNA_vDCMeas_pu = ( ((float32_t)(VIENNA_VDC_FB_1 + VIENNA_VDC_FB_2 +
            VIENNA_VDC_FB_3 + VIENNA_VDC_FB_4)) *
            (float32_t)ADC_VDC_GAIN * 0.25f - VIENNA_vDCMeasOffset_pu )*2.0;

    VIENNA_vCCMeas_pu = ( ((float32_t)(VIENNA_VCC_FB_1 + VIENNA_VCC_FB_2 +
            VIENNA_VCC_FB_3 + VIENNA_VCC_FB_4)) *
            (float32_t)ADC_VCC_GAIN * 0.25 )*2.0;

    VIENNA_TEMPMeas_pu = ( ((float32_t)(VIENNA_TEMP_FB_1 + VIENNA_TEMP_FB_2 +
            VIENNA_TEMP_FB_3 + VIENNA_TEMP_FB_4)) *
            (float32_t)ADC_TEMP_GAIN * 0.25f )*2.0;

    VIENNA_POTMeas_pu = ( ((float32_t)(VIENNA_POT_FB_1 + VIENNA_POT_FB_2 +
            VIENNA_POT_FB_3 + VIENNA_POT_FB_4)) *
            (float32_t)ADC_POT_GAIN * 0.25f )*2.0;

    //
    // clamp the vBusHalfMeas before dividing to avoid NaN
    //
//    VIENNA_vBusHalfMeas_pu = (VIENNA_vBusHalfMeas_pu < 0.2f)?0.2f:VIENNA_vBusHalfMeas_pu;

}

#pragma FUNC_ALWAYS_INLINE(filter_vdc)
static inline void filter_vdc(void)  //vdc filtering
{
    sensor_v_dc_fltr = 0.8817652051* sensor_v_dc_fltr+ 0.0591173974* (VIENNA_vDCMeas_pu + sensor_v_dc_prev); //0.8817652051,0.0591173974 for wc=2*pi*200 with Ts=1/10kHz  k1=(2Tau-Ts)/(2Tau+Ts); k2=Ts/(2Tau+Ts)
    sensor_v_dc_prev = VIENNA_vDCMeas_pu;
}

#pragma FUNC_ALWAYS_INLINE(filter_iL1)
static inline void filter_iL1(void)  //vpv filtering
{
    sensor_i_L1_fltr = 0.2282609* sensor_i_L1_fltr+ 0.3858695* (VIENNA_iL1Meas_pu + sensor_i_L1_prev); //0.2282609,0.3858695 for wc=2*pi*2000 with Ts=1/10kHz  k1=(2Tau-Ts)/(2Tau+Ts); k2=Ts/(2Tau+Ts)
    sensor_i_L1_prev = VIENNA_iL1Meas_pu;
}

#pragma FUNC_ALWAYS_INLINE(filter_iL2)
static inline void filter_iL2(void)  //vpv filtering
{
    sensor_i_L2_fltr = 0.2282609* sensor_i_L2_fltr+ 0.3858695* (VIENNA_iL2Meas_pu + sensor_i_L2_prev); //0.2282609,0.3858695 for wc=2*pi*2000 with Ts=1/10kHz  k1=(2Tau-Ts)/(2Tau+Ts); k2=Ts/(2Tau+Ts)
    sensor_i_L2_prev = VIENNA_iL2Meas_pu;
}

#pragma FUNC_ALWAYS_INLINE(filter_signals)
static inline void filter_signals(void)
{
    filter_vdc();
    filter_iL1();
    filter_iL2();
}

#pragma FUNC_ALWAYS_INLINE(filter_vpv2)
static inline void filter_vpv2(void)  //vpv filtering
{
    sensor_v_pv2_fltr = 0.2283* sensor_v_pv2_fltr+ 0.3859* (VIENNA_vPV2Meas_pu + sensor_v_pv2_prev); //0.2283,0.3859 for fc=10k with Ts=1/50kHz
    sensor_v_pv2_prev = VIENNA_vPV2Meas_pu;
}

#pragma FUNC_ALWAYS_INLINE(filter_ipv2)
static inline void filter_ipv2(void)  //vpv filtering
{
    sensor_i_pv2_fltr = 0.2283* sensor_i_pv2_fltr+ 0.3859* (VIENNA_iPV2Meas_pu + sensor_i_pv2_prev); //0.2283,0.3859 for fc=10k with Ts=1/50kHz
    sensor_i_pv2_prev = VIENNA_iPV2Meas_pu;
}

#pragma FUNC_ALWAYS_INLINE(filter_signals2)
static inline void filter_signals2(void)
{
//    filter_vdc();
    filter_vpv2();
    filter_ipv2();
}

#pragma FUNC_ALWAYS_INLINE(ControlCode_PVEmu)
static inline void ControlCode_PVEmu(void)
{
//    uint16_t duty1, duty2;

/*

    readCurrVolADCSignals();    //It takes 2.5usec
//    VIENNA_readCurrVolADCSignals();
    filter_signals();
    filter_signals2();
*/

//        (*PowerControl_State_Ptr1)();   // jump to an Alpha state (void Monitor_Vdc,Idle_State,Slew_Control,Vpv_Control)

/*
    if (CONTROL_STATE==FAULT_STATE || CONTROL_STATE2==FAULT_STATE){
        Fault_State();
    }
    else if (CONTROL_STATE==VDC_CHARGING || CONTROL_STATE2==VDC_CHARGING){
        Vdc_Charging();
    }
    else {

        switch (CONTROL_STATE) {    //switch-case adding 0.4usec to vpv_control1;
            case VPV_CONTROL1:
                Vpv_Control1();
                break;
*/
/*
            case VDC_CHARGING:
                Vdc_Charging();
                break;
*/
/*
            case SLEW_CONTROL1:
                Slew_Control1();
                break;
            case IDLE_STATE1:
                Idle_State1();
                break;
            case DEACCELERATION1:
                Deacceleration1();
                break;
*/
/*
            case FAULT_STATE:
                Fault_State();
                 break;
*/
/*
            default:
                break;
        }

        switch (CONTROL_STATE2) {    //switch-case adding 0.4usec to vpv_control1;
            case VPV_CONTROL2:
                Vpv_Control2();
                break;
*/
/*
            case VDC_CHARGING:
                Vdc_Charging();
                break;
*/
/*
            case SLEW_CONTROL2:
                Slew_Control2();
                break;
            case IDLE_STATE2:
                Idle_State2();
                break;
            case DEACCELERATION2:
                Deacceleration2();
                break;
*/
/*
            case FAULT_STATE:
                Fault_State();
                 break;
*/
/*
            default:
                break;
        }
    }
*/

//ONLY FOR TESTING
//    vpv_ref1_generation();

// Below CPU/CLA selections and math is working properly
/*
#if VIENNA_CONTROL_RUNNING_ON == C28x_CORE
    common_vars_duty1 = sinf(3.5);
#endif

#if VIENNA_CONTROL_RUNNING_ON == CLA_CORE
    common_vars_duty1 = CLAsin(3.5);
#endif
*/


/*
    if (CONTROL_STATE==VPV_CONTROL1  || CONTROL_STATE==SLEW_CONTROL1 || CONTROL_STATE==DEACCELERATION1) {
        // PWM Driver for channel1
        if (common_vars_duty1>0.6) common_vars_duty1 = 0.6;
        if (common_vars_duty1<=0.0) common_vars_duty1 = 0.0;



        duty1 =  (uint16_t) ( (float32_t) ((float32_t)(VIENNA_PFC3PH_PWM_PERIOD / 2.0)) * (float32_t) fabsf((1.0-common_vars_duty1)) );   //LATER FEED CONSTANT VALUE FOR: VIENNA_PFC3PH_PWM_PERIOD / 2.0

//        VIENNA_HAL_EPWM_setCounterCompareValueOptimized(EPWM1_BASE, EPWM_COUNTER_COMPARE_A, duty1);

//        EPwm1Regs.CMPA.bit.CMPA = EPwm1Regs.TBPRD - common_vars.duty1*(EPwm1Regs.TBPRD);
    }
*/


/*
    if (CONTROL_STATE2==VPV_CONTROL2  || CONTROL_STATE2==SLEW_CONTROL2 || CONTROL_STATE2==DEACCELERATION2) {
        // PWM Driver for channel1
        if (common_vars_duty2>0.6) common_vars_duty2 = 0.6;
        if (common_vars_duty2<=0.0) common_vars_duty2 = 0.0;



        duty2 =  (uint16_t) ( (float32_t) ((float32_t)(VIENNA_PFC3PH_PWM_PERIOD / 2.0)) * (float32_t) fabsf((1.0-common_vars_duty2)) );   //LATER FEED CONSTANT VALUE FOR: VIENNA_PFC3PH_PWM_PERIOD / 2.0

//        VIENNA_HAL_EPWM_setCounterCompareValueOptimized(EPWM2_BASE, EPWM_COUNTER_COMPARE_A, duty2);

//        EPwm1Regs.CMPA.bit.CMPA = EPwm1Regs.TBPRD - common_vars.duty1*(EPwm1Regs.TBPRD);
    }
*/

    VIENNA_HAL_clearPWMInterruptFlag(VIENNA_C28x_ISR1_INTERRUPT_TRIG_PWM_BASE);

}

#pragma FUNC_ALWAYS_INLINE(protections)
static inline void protections(void)
{
#if VIENNA_INSTRUMENTATION_ISR_RUNNING_ON == C28x_CORE
    EINT;
#endif
/*
    if(VIENNA_PWM_EMU_TRIP_STATUS(VIENNA_HIGH_FREQ_PWM1_BASE))
    {
        VIENNA_boardStatus = boardStatus_Idle;
    }
    else if(VIENNA_vDCMeas_pu > 750.0)
*/
/*

    if(VIENNA_vDCMeas_pu > 750.0)
    {
        EPWM_forceTripZoneEvent(EPWM1_BASE, EPWM_TZ_FORCE_EVENT_OST); //forceOSTPWMTrip
        EPWM_forceTripZoneEvent(EPWM2_BASE, EPWM_TZ_FORCE_EVENT_OST); //forceOSTPWMTrip
        EPWM_forceTripZoneEvent(EPWM3_BASE, EPWM_TZ_FORCE_EVENT_OST); //forceOSTPWMTrip

        VIENNA_boardStatus =   boardStatus_OverVoltageTrip;
    }
    else if( VIENNA_vDCMeas_pu < 400.0 )
        {
            EPWM_forceTripZoneEvent(EPWM1_BASE, EPWM_TZ_FORCE_EVENT_OST); //forceOSTPWMTrip
            EPWM_forceTripZoneEvent(EPWM2_BASE, EPWM_TZ_FORCE_EVENT_OST); //forceOSTPWMTrip
            EPWM_forceTripZoneEvent(EPWM3_BASE, EPWM_TZ_FORCE_EVENT_OST); //forceOSTPWMTrip

            VIENNA_boardStatus = vdc_undervoltage;
        }

    else if( (VIENNA_vPV1Meas_pu > update_const_vpv_overvoltage_threshold) || (VIENNA_vPV2Meas_pu > 500.0) )
    {
        EPWM_forceTripZoneEvent(EPWM1_BASE, EPWM_TZ_FORCE_EVENT_OST); //forceOSTPWMTrip
        EPWM_forceTripZoneEvent(EPWM2_BASE, EPWM_TZ_FORCE_EVENT_OST); //forceOSTPWMTrip
        EPWM_forceTripZoneEvent(EPWM3_BASE, EPWM_TZ_FORCE_EVENT_OST); //forceOSTPWMTrip

        VIENNA_boardStatus = vpv1_overvoltage;
    }
    else if( (VIENNA_vPV2Meas_pu > update_const_vpv_overvoltage_threshold) || (VIENNA_vPV2Meas_pu > 500.0) )
    {
        EPWM_forceTripZoneEvent(EPWM1_BASE, EPWM_TZ_FORCE_EVENT_OST); //forceOSTPWMTrip
        EPWM_forceTripZoneEvent(EPWM2_BASE, EPWM_TZ_FORCE_EVENT_OST); //forceOSTPWMTrip
        EPWM_forceTripZoneEvent(EPWM3_BASE, EPWM_TZ_FORCE_EVENT_OST); //forceOSTPWMTrip

        VIENNA_boardStatus = vpv2_overvoltage;
    }
    else if(VIENNA_CURR_TRIP_LATCH_STATUS(VIENNA_BOARD_PROT_IL1_CUR_CMPSS_BASE))   //??? LOOKS LIKE THERE IS SOME PROBLEM IN PASSING BASE ADDRESS
    {
        VIENNA_boardStatus = boardStatus_OverCurrentTrip_IL1;
    }
    else if(VIENNA_CURR_TRIP_LATCH_STATUS(VIENNA_BOARD_PROT_IL2_CUR_CMPSS_BASE))   //??? LOOKS LIKE THERE IS SOME PROBLEM IN PASSING BASE ADDRESS
    {
        VIENNA_boardStatus = boardStatus_OverCurrentTrip_IL2;
    }

    else if(VIENNA_CURR_TRIP_LATCH_STATUS(VIENNA_BOARD_PROT_IL3_CUR_CMPSS_BASE))   //??? LOOKS LIKE THERE IS SOME PROBLEM IN PASSING BASE ADDRESS
    {
        VIENNA_boardStatus = boardStatus_OverCurrentTrip_IL3;
    }

    else if(VIENNA_PWM_OC_TRIP_STATUS(VIENNA_HIGH_FREQ_PWM1_BASE)!= 0)
    {
        VIENNA_boardStatus = boardStatus_OverCurrentTrip;
    }

    else
    {
        VIENNA_boardStatus = boardStatus_NoFault;
    }

    if (!(VIENNA_boardStatus == boardStatus_NoFault)){//&&(VIENNA_boardStatus != boardStatus_Idle)) {  //IT LOOKS LIKE LOGIC "NOT EQUAL TO" IS NOT WORKING IN CLA
//        DisablePWM = SET;
        setDISABLE_PWM1();
        CONTROL_STATE = FAULT_STATE;
        Screen_count = 9;
//        LCD_ACTION = SCREEN9R1;
        common_flag_clearTripPWM1 = 0;
    }
*/
}



//==============-------------


#pragma FUNC_ALWAYS_INLINE(VIENNA_pfcControlCode)

//
// control Code
//
static inline void VIENNA_pfcControlCode(void)
{
/*
    VIENNA_HAL_setProfilingGPIO();

    VIENNA_readCurrVolADCSignals();

    #if VIENNA_SDFM_SENSING == 1
        VIENNA_readCurrVolSDFMSignals(VIENNA_SD32_PU_SCALE_FACTOR);
    #endif

    #if(VIENNA_ALL_PHASE_ENABLED == 1)
        VIENNA_clearPWMTrip();
    #else
        if(VIENNA_clearTrip == 1)
        {
            #if CHECK_PHASE == 1
                clearPWMTripFlags(VIENNA_HIGH_FREQ_PWM1_BASE);
            #elif CHECK_PHASE == 2
                clearPWMTripFlags(VIENNA_HIGH_FREQ_PWM2_BASE);
            #elif CHECK_PHASE == 3
                clearPWMTripFlags(VIENNA_HIGH_FREQ_PWM3_BASE);
            #else
                #warning define CHECK_PHASE in this build
            #endif
            VIENNA_clearTrip = 0;
        }
    #endif

    //
    // BUILD 1
    // Open Loop Check
    //
    #if(VIENNA_INCR_BUILD == 1)
//      VIENNA_duty1PU = VIENNA_dutyPU_DC;
        VIENNA_duty1PU = VIENNA_SFRA_INJECT(VIENNA_dutyPU_DC);
        VIENNA_duty2PU = VIENNA_dutyPU_DC;
        VIENNA_duty3PU = VIENNA_dutyPU_DC;

    //
    // (VIENNA_INCR_BUILD == 1)
    //
    #endif

    //
    // Closed Current Loop
    //
    #if(VIENNA_INCR_BUILD == 2 || VIENNA_INCR_BUILD == 3 || VIENNA_INCR_BUILD == 4)

        VIENNA_iL1Ref_pu = VIENNA_iLRef_pu * (VIENNA_v1Meas_pu / VIENNA_vRmsMeasAvg_pu);
        VIENNA_iL2Ref_pu = VIENNA_iLRef_pu * (VIENNA_v2Meas_pu / VIENNA_vRmsMeasAvg_pu);
        VIENNA_iL3Ref_pu = VIENNA_iLRef_pu * (VIENNA_v3Meas_pu / VIENNA_vRmsMeasAvg_pu);

        #if VIENNA_INDUCTOR_VOLTAGE_DROP_FEEDFORWARD == 1

        //
        // inductor voltage drop feed forward (L*di/dt)
        //
        VIENNA_inductor_voltage_drop_feedforward1 =
                    (VIENNA_iL1Ref_pu - VIENNA_iL1Ref_prev_pu) *
                    (VIENNA_PFC_INDUCTOR_VALUE * VIENNA_ISR_CONTROL_FREQUENCY_HZ
                    * VIENNA_I_MAX_SENSE_AMPS / VIENNA_V_MAX_SENSE_VOLTS);
        VIENNA_inductor_voltage_drop_feedforward2 =
                    (VIENNA_iL2Ref_pu - VIENNA_iL2Ref_prev_pu) *
                    (VIENNA_PFC_INDUCTOR_VALUE * VIENNA_ISR_CONTROL_FREQUENCY_HZ
                    * VIENNA_I_MAX_SENSE_AMPS / VIENNA_V_MAX_SENSE_VOLTS);
        VIENNA_inductor_voltage_drop_feedforward3 =
                    (VIENNA_iL3Ref_pu - VIENNA_iL3Ref_prev_pu) *
                    (VIENNA_PFC_INDUCTOR_VALUE * VIENNA_ISR_CONTROL_FREQUENCY_HZ
                    * VIENNA_I_MAX_SENSE_AMPS / VIENNA_V_MAX_SENSE_VOLTS);
        #else
            VIENNA_inductor_voltage_drop_feedforward1 = 0;
            VIENNA_inductor_voltage_drop_feedforward2 = 0;
            VIENNA_inductor_voltage_drop_feedforward3 = 0;
        #endif

        #ifdef __TMS320C28XX_CLA__
            #if(CLA_DEBUG == 1)
                __mdebugstop();
            #endif
        #endif

        if(VIENNA_closeGiLoop == 1)
        {

            #if VIENNA_SFRA_TYPE == VIENNA_SFRA_CURRENT
                VIENNA_gi_out1 = (VIENNA_iL1Meas_pu -
                        VIENNA_SFRA_INJECT(VIENNA_iL1Ref_pu)) * VIENNA_gi_gainKp;
            #else
                VIENNA_gi_out1 = (VIENNA_iL1Meas_pu - VIENNA_iL1Ref_pu) *
                VIENNA_gi_gainKp;
            #endif
                VIENNA_gi_out2 = (VIENNA_iL2Meas_pu - VIENNA_iL2Ref_pu) *
                VIENNA_gi_gainKp;
                VIENNA_gi_out3 = (VIENNA_iL3Meas_pu - VIENNA_iL3Ref_pu) *
                VIENNA_gi_gainKp;

            #if VIENNA_THIRD_HARMONIC_INJECTION == 0
                VIENNA_thirdHarmonicInjection = 0;
            #else
                VIENNA_vMin_pu = (VIENNA_v1Meas_pu < VIENNA_v2Meas_pu)?
                               VIENNA_v1Meas_pu:VIENNA_v2Meas_pu;
                VIENNA_vMin_pu = (VIENNA_vMin_pu < VIENNA_v3Meas_pu)?
                               VIENNA_vMin_pu:VIENNA_v3Meas_pu;
                VIENNA_vMax_pu = (VIENNA_v1Meas_pu > VIENNA_v2Meas_pu)?
                               VIENNA_v1Meas_pu:VIENNA_v2Meas_pu;
                VIENNA_vMax_pu = (VIENNA_vMax_pu > VIENNA_v3Meas_pu)?
                               VIENNA_vMax_pu:VIENNA_v3Meas_pu;

                VIENNA_thirdHarmonicInjection = (VIENNA_vMin_pu + VIENNA_vMax_pu)
                                                * 0.5f;
            #endif


                VIENNA_duty1PU = ( (VIENNA_gi_out1
                            + VIENNA_inductor_voltage_drop_feedforward1
                            + VIENNA_v1Meas_pu
                            - VIENNA_thirdHarmonicInjection
                            ) / VIENNA_vBusHalfMeas_pu ) - VIENNA_gs_out;

                VIENNA_duty2PU = ( (VIENNA_gi_out2
                            + VIENNA_inductor_voltage_drop_feedforward2
                            + VIENNA_v2Meas_pu
                            - VIENNA_thirdHarmonicInjection
                            ) / VIENNA_vBusHalfMeas_pu ) - VIENNA_gs_out;


                VIENNA_duty3PU = ( (VIENNA_gi_out3
                            + VIENNA_inductor_voltage_drop_feedforward3
                            + VIENNA_v3Meas_pu
                            - VIENNA_thirdHarmonicInjection
                             ) / VIENNA_vBusHalfMeas_pu ) - VIENNA_gs_out;
        }
        else
        {
            VIENNA_duty1PU = 1.0f;
            VIENNA_duty2PU = 1.0f;
            VIENNA_duty3PU = 1.0f;
        }

    #endif

    //
    // PWM Driver for three phase Vienna Rectifier PFC
    //
    VIENNA_duty1PU = (VIENNA_duty1PU > 1.0f)?1.0f:VIENNA_duty1PU;
    VIENNA_duty1PU = (VIENNA_duty1PU < -1.0f)?-1.0f:VIENNA_duty1PU;
    VIENNA_duty2PU = (VIENNA_duty2PU > 1.0f)?1.0f:VIENNA_duty2PU;
    VIENNA_duty2PU = (VIENNA_duty2PU < -1.0f)?-1.0f:VIENNA_duty2PU;
    VIENNA_duty3PU = (VIENNA_duty3PU > 1.0f)?1.0f:VIENNA_duty3PU;
    VIENNA_duty3PU = (VIENNA_duty3PU < -1.0f)?-1.0f:VIENNA_duty3PU;

    VIENNA_HAL_updatePFCviennaPWM(VIENNA_HIGH_FREQ_PWM1_BASE,
                                  VIENNA_HIGH_FREQ_PWM2_BASE,
                                  VIENNA_HIGH_FREQ_PWM3_BASE,
                                  VIENNA_duty1PU,
                                  VIENNA_duty2PU,
                                  VIENNA_duty3PU);

    VIENNA_iL1Ref_prev_pu = VIENNA_iL1Ref_pu;
    VIENNA_iL2Ref_prev_pu = VIENNA_iL2Ref_pu;
    VIENNA_iL3Ref_prev_pu = VIENNA_iL3Ref_pu;

    #ifdef __TMS320C28XX_CLA__
       #if(CLA_DEBUG == 1)
           __mdebugstop();
       #endif
    #endif

    //
    // BUILD 3
    //
    #if(VIENNA_INCR_BUILD == 3 || VIENNA_INCR_BUILD == 4)

        if(VIENNA_closeGvLoop == 1)
        {
            if(VIENNA_firstTimeGvLoop == 1)
            {
                VIENNA_vBusRefSlewed_pu = VIENNA_vBusMeas_pu;
                VIENNA_firstTimeGvLoop = 0;
            }

            VIENNA_voltage_error_pu = fabs(VIENNA_vBusRefSlewed_pu - VIENNA_vBusMeas_pu);

            if(VIENNA_nonLinearVoltageLoopFlag == 0)
            {
                VIENNA_gv.Kp = VIENNA_GV_PI_KP;
                VIENNA_gv.Ki = VIENNA_GV_PI_KI;
            }
            else
            {
               if(VIENNA_voltage_error_pu > 0.005f)
               {
                   if(VIENNA_gv.Kp < (VIENNA_NON_LINEAR_V_LOOP_KP_MULTIPLIER
                           * VIENNA_GV_PI_KP))
                   {
                       VIENNA_gv.Kp = VIENNA_gv.Kp + 0.05f;
                   }
               }
               else if(VIENNA_voltage_error_pu < 0.001f)
               {
                   if(VIENNA_gv.Kp > VIENNA_GV_PI_KP)
                   {
                       VIENNA_gv.Kp = VIENNA_gv.Kp - 0.05f;
                   }
               }
            }

            #if VIENNA_SFRA_TYPE == VIENNA_SFRA_VOLTAGE
                VIENNA_gv_out = VIENNA_GV_RUN(&VIENNA_gv,
                                VIENNA_SFRA_INJECT(VIENNA_vBusRefSlewed_pu),
                                VIENNA_vBusMeas_pu);
            #else
                VIENNA_gv_out = VIENNA_GV_RUN(&VIENNA_gv, VIENNA_vBusRefSlewed_pu,
                                            VIENNA_vBusMeas_pu);
            #endif

                //
                // Output of the voltage loop is thought to be the Power
                //
                VIENNA_iLRef_pu = VIENNA_gv_out *
                        (VIENNA_vBusMeasAvg_pu / (3 * VIENNA_vRmsMeasAvg_pu));

        }
    #endif



    #if(VIENNA_INCR_BUILD == 4)
        if(VIENNA_closeGsLoop == 1)
        {
            VIENNA_vBusDiff_pu = VIENNA_vBusPMMeas_pu - VIENNA_vBusMNMeas_pu;

            #if VIENNA_SFRA_TYPE == VIENNA_SFRA_BALANCECNTL
                VIENNA_gs_out = (VIENNA_vBusDiff_pu - VIENNA_SFRA_INJECT(VIENNA_vBusZero_pu))
                                * VIENNA_gs_gainKp;
//              VIENNA_gs_out = (VIENNA_vBusDiff_pu)*VIENNA_gs_gainKp;
            #else
                VIENNA_gs_out = (VIENNA_vBusDiff_pu) * VIENNA_gs_gainKp;
            #endif
        }
        else
        {
            VIENNA_gs_out = 0;
        }
    #else
        VIENNA_gs_out = 0;
    #endif

    //
    //Running FRA on Voltage
    //
    #if(VIENNA_SFRA_TYPE == VIENNA_SFRA_VOLTAGE )
        VIENNA_SFRA_COLLECT((float32_t *)&VIENNA_gv_out,
                            (float32_t *)&VIENNA_vBusMeas_pu);

    //
    //running FRA on Current
    //
    #elif(VIENNA_SFRA_TYPE == VIENNA_SFRA_CURRENT)
        VIENNA_SFRA_COLLECT((float32_t *)&VIENNA_gi_out1,
                            (float32_t *)&VIENNA_iL1Meas_pu);
    #elif(VIENNA_SFRA_TYPE == VIENNA_SFRA_BALANCECNTL)
        VIENNA_SFRA_COLLECT((float32_t *)&VIENNA_gs_out,
                            (float32_t *)&VIENNA_vBusDiff_pu);
    #endif

   VIENNA_HAL_clearPWMInterruptFlag(VIENNA_C28x_ISR1_INTERRUPT_TRIG_PWM_BASE);

   VIENNA_HAL_resetProfilingGPIO();
*/
}

#pragma FUNC_ALWAYS_INLINE(VIENNA_instrumentationCode)

//
// voltage loop plus instrumentation code
//
static inline void VIENNA_instrumentationCode()
{
    //
    // Let the ISR1 interrupt this routine
    //
#if VIENNA_INSTRUMENTATION_ISR_RUNNING_ON == C28x_CORE
    EINT;
#endif
/*
    VIENNA_HAL_setProfilingGPIO2();

    if(VIENNA_closeGvLoop == 1)
    {
        if(fabsf(VIENNA_vBusRef_pu - VIENNA_vBusRefSlewed_pu) > 0.1f)
        {
            if(VIENNA_vBusRef_pu > VIENNA_vBusRefSlewed_pu)
            {
                VIENNA_vBusRefSlewed_pu = VIENNA_vBusRefSlewed_pu + 0.0001f;
            }
            else
            {
                VIENNA_vBusRefSlewed_pu = VIENNA_vBusRefSlewed_pu - 0.0001f;
            }
        }
        else if(fabsf(VIENNA_vBusRef_pu - VIENNA_vBusRefSlewed_pu) > 0.01f)
        {
            if(VIENNA_vBusRef_pu > VIENNA_vBusRefSlewed_pu)
            {
                VIENNA_vBusRefSlewed_pu = VIENNA_vBusRefSlewed_pu + 0.00005f;
            }
            else
            {
                VIENNA_vBusRefSlewed_pu = VIENNA_vBusRefSlewed_pu - 0.00005f;
            }
        }
        else if(fabsf(VIENNA_vBusRef_pu - VIENNA_vBusRefSlewed_pu) > 0.005f)
        {
            if(VIENNA_vBusRef_pu > VIENNA_vBusRefSlewed_pu)
            {
                VIENNA_vBusRefSlewed_pu = VIENNA_vBusRefSlewed_pu + 0.00001f;
            }
            else
            {
                VIENNA_vBusRefSlewed_pu = VIENNA_vBusRefSlewed_pu - 0.00001f;
            }
        }
        else
        {
            VIENNA_vBusRefSlewed_pu = VIENNA_vBusRef_pu;
        }
    }


    if(VIENNA_PWM_EMU_TRIP_STATUS(VIENNA_HIGH_FREQ_PWM1_BASE))
    {
        VIENNA_boardStatus = boardStatus_Idle;
    }
    else if(VIENNA_guiVbus_Volts > VIENNA_guiVbusTripLimit_Volts || VIENNA_guiVbusPM_Volts > 415.0f
            || VIENNA_guiVbusMN_Volts > 415.0f)
    {
        VIENNA_HAL_forceOSTPWMTrip(VIENNA_HIGH_FREQ_PWM1_BASE);
        VIENNA_HAL_forceOSTPWMTrip(VIENNA_HIGH_FREQ_PWM2_BASE);
        VIENNA_HAL_forceOSTPWMTrip(VIENNA_HIGH_FREQ_PWM3_BASE);
        VIENNA_boardStatus =   boardStatus_OverVoltageTrip;
    }
    else if(fabsf(VIENNA_guiVbusPM_Volts - VIENNA_guiVbusMN_Volts) > 50)
    {
        VIENNA_HAL_forceOSTPWMTrip(VIENNA_HIGH_FREQ_PWM1_BASE);
        VIENNA_HAL_forceOSTPWMTrip(VIENNA_HIGH_FREQ_PWM2_BASE);
        VIENNA_HAL_forceOSTPWMTrip(VIENNA_HIGH_FREQ_PWM3_BASE);
//        VIENNA_boardStatus = boardStatus_BusImbalanceTrip;
    }
    else if(VIENNA_CURR_TRIP_LATCH_STATUS(VIENNA_BOARD_PROT_IL1_CUR))
    {
        VIENNA_boardStatus = boardStatus_OverCurrentTrip_IL1;
    }
    else if(VIENNA_CURR_TRIP_LATCH_STATUS(VIENNA_BOARD_PROT_IL2_CUR))
    {
        VIENNA_boardStatus = boardStatus_OverCurrentTrip_IL2;
    }
    else if(VIENNA_CURR_TRIP_LATCH_STATUS(VIENNA_BOARD_PROT_IL3_CUR))
    {
        VIENNA_boardStatus = boardStatus_OverCurrentTrip_IL3;
    }
    else if(VIENNA_PWM_OC_TRIP_STATUS(VIENNA_HIGH_FREQ_PWM1_BASE)!= 0)
    {
        VIENNA_boardStatus = boardStatus_OverCurrentTrip;
    }
    else
    {
        VIENNA_boardStatus = boardStatus_NoFault;
    }

    EMAVG_MACRO(VIENNA_vBusPMMeas_pu, VIENNA_vBusPMMeasAvg_pu);
    EMAVG_MACRO(VIENNA_vBusMNMeas_pu, VIENNA_vBusMNMeasAvg_pu);

    VIENNA_vBusMeasAvg_pu = VIENNA_vBusPMMeasAvg_pu + VIENNA_vBusMNMeasAvg_pu;

    VIENNA_guiVbusPM_Volts = VIENNA_vBusPMMeasAvg_pu * VIENNA_V_MAX_SENSE_VOLTS;
    VIENNA_guiVbusMN_Volts = VIENNA_vBusMNMeasAvg_pu * VIENNA_V_MAX_SENSE_VOLTS;
    VIENNA_guiVbus_Volts = VIENNA_guiVbusPM_Volts + VIENNA_guiVbusMN_Volts;

    VIENNA_guiV1_Volts = VIENNA_v1Meas_pu * VIENNA_V_MAX_SENSE_VOLTS;
    VIENNA_guiV2_Volts = VIENNA_v2Meas_pu * VIENNA_V_MAX_SENSE_VOLTS;
    VIENNA_guiV3_Volts = VIENNA_v3Meas_pu * VIENNA_V_MAX_SENSE_VOLTS;

    VIENNA_guiIL1_Amps = VIENNA_iL1Meas_pu * VIENNA_I_MAX_SENSE_AMPS;
    VIENNA_guiIL2_Amps = VIENNA_iL2Meas_pu * VIENNA_I_MAX_SENSE_AMPS;
    VIENNA_guiIL3_Amps = VIENNA_iL3Meas_pu * VIENNA_I_MAX_SENSE_AMPS;

//  VIENNA_guiIL1sd = VIENNA_iL1MeasSD_pu * VIENNA_I_MAX_SENSE_SD_AMPS;
//  VIENNA_guiIL2sd = VIENNA_iL2MeasSD_pu * VIENNA_I_MAX_SENSE_SD_AMPS;
//  VIENNA_guiIL3sd = VIENNA_iL3MeasSD_pu * VIENNA_I_MAX_SENSE_SD_AMPS;

    //
    // Sine Analyzer
    // Calculate RMS input voltage and input frequency
    //
    VIENNA_sine_mains1.i = VIENNA_iL1Meas_pu;
    VIENNA_sine_mains1.v = VIENNA_v1Meas_pu;
    POWER_MEAS_SINE_ANALYZER_run(&VIENNA_sine_mains1);

    VIENNA_sine_mains2.i = VIENNA_iL2Meas_pu;
    VIENNA_sine_mains2.v = VIENNA_v2Meas_pu;
    POWER_MEAS_SINE_ANALYZER_run(&VIENNA_sine_mains2);

    VIENNA_sine_mains3.i = VIENNA_iL3Meas_pu;
    VIENNA_sine_mains3.v = VIENNA_v3Meas_pu;
    POWER_MEAS_SINE_ANALYZER_run(&VIENNA_sine_mains3);

    EMAVG_MACRO(VIENNA_sine_mains1.vRms, VIENNA_vRmsMeasAvg_pu);

    VIENNA_guiIrms1_Amps = VIENNA_sine_mains1.iRms * VIENNA_I_MAX_SENSE_AMPS;
    VIENNA_guiVrms1_Volts = VIENNA_sine_mains1.vRms * VIENNA_V_MAX_SENSE_VOLTS;
    VIENNA_guiPrms1_W = VIENNA_sine_mains1.pRms * VIENNA_V_MAX_SENSE_VOLTS *
                      VIENNA_I_MAX_SENSE_AMPS;
    VIENNA_guiPF1 = VIENNA_sine_mains1.powerFactor;
    VIENNA_guiVA1_VA = VIENNA_sine_mains1.vaRms * VIENNA_V_MAX_SENSE_VOLTS *
                    VIENNA_I_MAX_SENSE_AMPS;

    VIENNA_guiIrms2_Amps = VIENNA_sine_mains2.iRms * VIENNA_I_MAX_SENSE_AMPS;
    VIENNA_guiVrms2_Volts = VIENNA_sine_mains2.vRms * VIENNA_V_MAX_SENSE_VOLTS;
    VIENNA_guiPrms2_W = VIENNA_sine_mains2.pRms * VIENNA_V_MAX_SENSE_VOLTS *
                      VIENNA_I_MAX_SENSE_AMPS;
    VIENNA_guiPF2 = VIENNA_sine_mains2.powerFactor;
    VIENNA_guiVA2_VA = VIENNA_sine_mains2.vaRms * VIENNA_V_MAX_SENSE_VOLTS *
                    VIENNA_I_MAX_SENSE_AMPS;

    VIENNA_guiIrms3_Amps = VIENNA_sine_mains3.iRms * VIENNA_I_MAX_SENSE_AMPS;
    VIENNA_guiVrms3_Volts = VIENNA_sine_mains3.vRms * VIENNA_V_MAX_SENSE_VOLTS;
    VIENNA_guiPrms3_W = VIENNA_sine_mains3.pRms * VIENNA_V_MAX_SENSE_VOLTS *
                      VIENNA_I_MAX_SENSE_AMPS;
    VIENNA_guiPF3 = VIENNA_sine_mains3.powerFactor;
    VIENNA_guiVA3_VA = VIENNA_sine_mains3.vaRms * VIENNA_V_MAX_SENSE_VOLTS *
                    VIENNA_I_MAX_SENSE_AMPS;

    VIENNA_guiACFreq_Hz = VIENNA_sine_mains1.acFreqAvg;

#ifndef __TMS320C28XX_CLA__

    //
    // DLOG
//
    //

    //
    // check voltage and inductor current meas.
    //
    VIENNA_dVal1 = VIENNA_guiV1_Volts;
    VIENNA_dVal2 = VIENNA_iL1Meas_pu;
    VIENNA_dVal3 = VIENNA_iL2Meas_pu;
    VIENNA_dVal4 = VIENNA_iL3Meas_pu;

    DLOG_4CH_run(&VIENNA_dLog1);
#endif

    VIENNA_HAL_resetProfilingGPIO2();
*/

}


#ifdef __cplusplus
}
#endif                                  /* extern "C" */


#endif
